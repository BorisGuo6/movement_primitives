<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>movement_primitives.kinematics API documentation</title>
<meta name="description" content="Forward kinematics and a simple implementation of inverse kinematics." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>movement_primitives.kinematics</code></h1>
</header>
<section id="section-intro">
<p>Forward kinematics and a simple implementation of inverse kinematics.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Forward kinematics and a simple implementation of inverse kinematics.&#34;&#34;&#34;
import numpy as np
import math
import numba
from pytransform3d.urdf import UrdfTransformManager
from scipy.optimize import minimize


class FastUrdfTransformManager(UrdfTransformManager):
    def __init__(self):
        super(FastUrdfTransformManager, self).__init__(check=False)

    def set_joint(self, joint_name, value):
        &#34;&#34;&#34;Set joint position.

        Note that joint values are clipped to their limits.

        Parameters
        ----------
        joint_name : string
            Name of the joint

        value : float
            Joint angle in radians in case of revolute joints or position
            in case of prismatic joint.
        &#34;&#34;&#34;
        from_frame, to_frame, child2parent, axis, limits, joint_type = \
            self._joints[joint_name]
        value = min(max(value, limits[0]), limits[1])
        if joint_type == &#34;revolute&#34;:
            joint2A = _fast_matrix_from_axis_angle(axis, value)
        else:
            joint2A = np.eye(4)
            joint2A[:3, 3] = value * axis
        self.transforms[(from_frame, to_frame)] = child2parent.dot(joint2A)

    def get_ee2base(self, ee_index, base_index):
        &#34;&#34;&#34;Request a transform.

        Parameters
        ----------
        ee_index : int
            Index of the end-effector node

        base_index : int
            Index of the base node

        Returns
        -------
        ee2base : array-like, shape (4, 4)
            Homogeneous matrix that represents the transform from ee to base
        &#34;&#34;&#34;
        return self._path_transform(self._shortest_path(ee_index, base_index))


@numba.jit(nopython=True, cache=True)
def _fast_matrix_from_axis_angle(axis, angle):
    &#34;&#34;&#34;Compute transformation matrix from axis-angle.

    Parameters
    ----------
    axis : array-like, shape (3,)
        Axis of rotation: (x, y, z).

    angle : float
        Rotation angle.

    Returns
    -------
    A2B : array-like, shape (4, 4)
        Transformation matrix
    &#34;&#34;&#34;
    ux, uy, uz = axis
    c = math.cos(angle)
    s = math.sin(angle)
    ci = 1.0 - c
    ciux = ci * ux
    ciuy = ci * uy
    ciuz = ci * uz
    return np.array([
        [ciux * ux + c, ciux * uy - uz * s, ciux * uz + uy * s, 0.0],
        [ciuy * ux + uz * s, ciuy * uy + c, ciuy * uz - ux * s, 0.0],
        [ciuz * ux - uy * s, ciuz * uy + ux * s, ciuz * uz + c, 0.0],
        [0.0, 0.0, 0.0, 1.0]
    ])


class Kinematics:
    &#34;&#34;&#34;Robot kinematics.

    Parameters
    ----------
    urdf : str
        URDF description of a robot

    mesh_path : str, optional (default: None)
        Path in which we search for meshes that are defined in the URDF.
        Meshes will be ignored if it is set to None.
    &#34;&#34;&#34;
    def __init__(self, urdf, mesh_path=None):
        self.tm = FastUrdfTransformManager()
        self.tm.load_urdf(urdf, mesh_path=mesh_path)

    def create_chain(self, joint_names, base_frame, ee_frame, verbose=0):
        &#34;&#34;&#34;Create kinematic chain.

        Parameters
        ----------
        joint_names : list
            Names of joints that should be used

        base_frame : str
            Name of the base link

        ee_frame : str
            Name of the end-effector link

        verbose : int, optional (default: 0)
            Verbosity level

        Returns
        -------
        chain : Chain
            Kinematic chain
        &#34;&#34;&#34;
        return Chain(self.tm, joint_names, base_frame, ee_frame, verbose)


class Chain:
    &#34;&#34;&#34;Kinematic chain.

    Parameters
    ----------
    tm : FastUrdfTransformManager
        Transformation manager

    joint_names : list
        Names of joints that should be used

    base_frame : str
        Name of the base link

    ee_frame : str
        Name of the end-effector link

    verbose : int, optional (default: 0)
        Verbosity level
    &#34;&#34;&#34;
    def __init__(self, tm, joint_names, base_frame, ee_frame, verbose=0):
        self.tm = tm
        self.joint_names = joint_names
        self.base_frame = base_frame
        self.ee_frame = ee_frame
        self.verbose = verbose

        self.joint_limits = np.array(
            [self.tm._joints[jn][4] for jn in self.joint_names])
        for i in range(len(self.joint_limits)):
            if np.isinf(self.joint_limits[i, 0]):
                self.joint_limits[i, 0] = -math.pi
            if np.isinf(self.joint_limits[i, 1]):
                self.joint_limits[i, 1] = math.pi

        self.n_joints = len(self.joint_names)
        assert len(self.joint_limits) == self.n_joints

        self.ee_index = self.tm.nodes.index(ee_frame)
        self.base_index = self.tm.nodes.index(base_frame)

    def forward(self, joint_angles):
        &#34;&#34;&#34;Forward kinematics.

        Parameters
        ----------
        joint_angles : array, shape (n_joints,)
            Joint angles

        Returns
        -------
        ee2base : array, shape (4, 4)
            Transformation from end-effector to base frame
        &#34;&#34;&#34;
        for i in range(self.n_joints):
            self.tm.set_joint(self.joint_names[i], joint_angles[i])
        return self.tm.get_ee2base(self.ee_index, self.base_index)

    def ee_pose_error(self, joint_angles, desired_pose, orientation_weight=1.0,
                      position_weight=1.0):
        &#34;&#34;&#34;Compute pose error.

        Parameters
        ----------
        joint_angles : array-like, shape (n_joints,)
            Actual joint angles for which we compute forward kinematics.

        desired_pose : array-like, shape (4, 4)
            Desired pose.

        orientation_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the orientation error.

        position_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the position error.

        Returns
        -------
        pose_error : float
            Weighted error between actual pose and desired pose.
        &#34;&#34;&#34;
        return pose_dist(desired_pose, self.forward(joint_angles),
                         orientation_weight, position_weight)

    def inverse(
            self, desired_pose, initial_joint_angles, return_error=False,
            bounds=None, solver=&#34;SLSQP&#34;, orientation_weight=1.0,
            position_weight=1.0):
        &#34;&#34;&#34;Inverse kinematics.

        Parameters
        ----------
        desired_pose : array, shape (4, 4)
            Desired transformation from end-effector to base frame

        initial_joint_angles : array, shape (n_joints,)
            Initial guess for joint angles

        return_error : bool, optional (default: False)
            Return error in addition to joint angles

        bounds : array, shape (n_joints, 2), optional (default: joint limits)
            Bounds for joint angle optimization

        solver : str, optional (default: &#39;SLSQP&#39;)
            Optimizer to solve inverse kinematics problem. Possible options:
            &#39;SLSQP&#39;, &#39;L-BFGS-B&#39;, and &#39;COBYLA&#39;.

        orientation_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the orientation error.

        position_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the position error.

        Returns
        -------
        joint_angles : array, shape (n_joints,)
            Solution

        error : float, optional
            Pose error
        &#34;&#34;&#34;
        if bounds is None:
            bounds = self.joint_limits
        res = minimize(
            self.ee_pose_error, initial_joint_angles,
            (desired_pose, orientation_weight, position_weight),
            method=solver, bounds=bounds)

        if self.verbose &gt;= 2:
            print(&#34;Error: %g&#34; % res[&#34;fun&#34;])
        if return_error:
            return res[&#34;x&#34;], res[&#34;fun&#34;]
        else:
            return res[&#34;x&#34;]

    def inverse_with_random_restarts(
            self, desired_pose, n_restarts=10, tolerance=1e-3,
            random_state=np.random, solver=&#34;SLSQP&#34;,
            orientation_weight=1.0, position_weight=1.0):
        &#34;&#34;&#34;Compute inverse kinematics with multiple random restarts.

        Parameters
        ----------
        desired_pose : array-like, shape (4, 4)
            Desired pose.

        n_restarts : int, optional (default: 10)
            Maximum number of allowed restarts.

        tolerance : float, optional (default: 1e-3)
            Required tolerance to abort.

        random_state : np.random.RandomState, optional (default: np.random)
            Random state.

        solver : str, optional (default: &#39;SLSQP&#39;)
            Optimizer to solve inverse kinematics problem. Possible options:
            &#39;SLSQP&#39;, &#39;L-BFGS-B&#39;, and &#39;COBYLA&#39;.

        orientation_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the orientation error.

        position_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the position error.

        Returns
        -------
        joint_angles : array, shape (n_joints,)
            Solution
        &#34;&#34;&#34;
        assert n_restarts &gt;= 1
        Q = []
        errors = []
        for _ in range(n_restarts):
            q, error = self.inverse(
                desired_pose, self._sample_joints_uniform(random_state),
                return_error=True, solver=solver,
                orientation_weight=orientation_weight,
                position_weight=position_weight)
            Q.append(q)
            errors.append(error)
            if error &lt;= tolerance:
                break
        if self.verbose:
            print(np.round(errors, 4))
        return Q[np.argmin(errors)]

    def local_inverse_with_random_restarts(
            self, desired_pose, joint_angles, interval, n_restarts=10,
            tolerance=1e-3, random_state=np.random, solver=&#34;SLSQP&#34;,
            orientation_weight=1.0, position_weight=1.0):
        &#34;&#34;&#34;Compute inverse kinematics with multiple random restarts.

        Parameters
        ----------
        desired_pose : array-like, shape (4, 4)
            Desired pose.

        joint_angles : array-like, shape (n_joints,)
            Initial guess for joint angles.

        interval : float
            We will search for a solution within the range
            [joint_angles - interval, joint_angles + interval].

        n_restarts : int, optional (default: 10)
            Maximum number of allowed restarts.

        tolerance : float, optional (default: 1e-3)
            Required tolerance to abort.

        random_state : np.random.RandomState, optional (default: np.random)
            Random state.

        solver : str, optional (default: &#39;SLSQP&#39;)
            Optimizer to solve inverse kinematics problem. Possible options:
            &#39;SLSQP&#39;, &#39;L-BFGS-B&#39;, and &#39;COBYLA&#39;.

        orientation_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the orientation error.

        position_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the position error.

        Returns
        -------
        joint_angles : array, shape (n_joints,)
            Solution
        &#34;&#34;&#34;
        assert n_restarts &gt;= 1
        Q = []
        errors = []
        bounds = np.empty((self.n_joints, 2))
        bounds[:, 0] = joint_angles - interval
        bounds[:, 1] = joint_angles + interval
        q = joint_angles  # start with previous state
        for _ in range(n_restarts):
            q, error = self.inverse(
                desired_pose, q, return_error=True, solver=solver,
                orientation_weight=orientation_weight,
                position_weight=position_weight)
            Q.append(q)
            errors.append(error)
            if error &lt;= tolerance:
                break
            q = self._sample_joints_uniform(random_state, bounds=bounds)
        return Q[np.argmin(errors)]

    def _sample_joints_uniform(self, random_state, bounds=None):
        if bounds is None:
            bounds = self.joint_limits
        return (random_state.rand(len(bounds)) * (bounds[:, 1] - bounds[:, 0])
                + bounds[:, 0])

    def forward_trajectory(self, Q):
        &#34;&#34;&#34;Compute forward kinematics for a trajectory.

        Parameters
        ----------
        Q : array-like, shape (n_steps, n_joints)
            Joint angles.

        Returns
        -------
        H : array, shape (n_steps, 4, 4)
            End-effector poses.
        &#34;&#34;&#34;
        H = np.empty((len(Q), 4, 4))
        for t in range(len(Q)):
            H[t] = self.forward(Q[t])
        return H

    def inverse_trajectory(
            self, H, initial_joint_angles=None, interval=0.1 * math.pi,
            random_restarts=True, random_state=np.random, solver=&#34;SLSQP&#34;,
            orientation_weight=1.0, position_weight=1.0):
        &#34;&#34;&#34;Compute inverse kinematics for a trajectory.

        Parameters
        ----------
        H : array-like, shape (n_steps, 4, 4)
            Desired end-effector poses.

        initial_joint_angles : array-like, shape (n_joints,), optional (default: None)
            Initial guess for joint angles.

        interval : float
            We will search for a solution within the range
            [joint_angles - interval, joint_angles + interval] in each step.

        random_restarts : bool, optional (default: True)
            Allow random restarts if no solution is found.

        random_state : np.random.RandomState, optional (default: np.random)
            Random state.

        solver : str, optional (default: &#39;SLSQP&#39;)
            Optimizer to solve inverse kinematics problem. Possible options:
            &#39;SLSQP&#39;, &#39;L-BFGS-B&#39;, and &#39;COBYLA&#39;.

        orientation_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the orientation error.

        position_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the position error.

        Returns
        -------
        Q : array, shape (n_steps, n_joints)
            Solution
        &#34;&#34;&#34;
        Q = np.empty((len(H), len(self.joint_names)), dtype=float)

        if initial_joint_angles is None:
            Q[0] = self.inverse_with_random_restarts(
                H[0], random_state=random_state,
                orientation_weight=orientation_weight,
                position_weight=position_weight)
        else:
            Q[0] = self.inverse(
                H[0], initial_joint_angles, solver=solver,
                orientation_weight=orientation_weight,
                position_weight=position_weight)

        for t in range(1, len(H)):
            if self.verbose &gt;= 2:
                print(&#34;Step: %d&#34; % (t + 1))
            if random_restarts:
                Q[t] = self.local_inverse_with_random_restarts(
                    H[t], Q[t - 1], interval, random_state=random_state,
                    orientation_weight=orientation_weight,
                    position_weight=position_weight)
            else:
                bounds = np.empty((self.n_joints, 2), dtype=float)
                bounds[:, 0] = Q[t - 1] - interval
                bounds[:, 1] = Q[t - 1] + interval
                Q[t] = self.inverse(
                    H[t], Q[t - 1], False, bounds, solver=solver,
                    orientation_weight=orientation_weight,
                    position_weight=position_weight)
        return Q


@numba.jit(nopython=True, cache=True)
def pose_dist(
        ee2base_desired, ee2base_actual, orientation_weight, position_weight):
    ee_actual2ee_desired = np.linalg.inv(ee2base_actual).dot(ee2base_desired)
    trace = (ee_actual2ee_desired[0, 0] + ee_actual2ee_desired[1, 1]
             + ee_actual2ee_desired[2, 2])
    angle = math.acos(min((trace - 1.0) / 2.0, 1.0))
    orientation_error = min(angle, 2.0 * math.pi - angle)
    position_error = math.sqrt(
        ee_actual2ee_desired[0, 3] ** 2 + ee_actual2ee_desired[1, 3] ** 2
        + ee_actual2ee_desired[2, 3] ** 2)
    return (orientation_weight * orientation_error
            + position_weight * position_error)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="movement_primitives.kinematics.pose_dist"><code class="name flex">
<span>def <span class="ident">pose_dist</span></span>(<span>ee2base_desired, ee2base_actual, orientation_weight, position_weight)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.jit(nopython=True, cache=True)
def pose_dist(
        ee2base_desired, ee2base_actual, orientation_weight, position_weight):
    ee_actual2ee_desired = np.linalg.inv(ee2base_actual).dot(ee2base_desired)
    trace = (ee_actual2ee_desired[0, 0] + ee_actual2ee_desired[1, 1]
             + ee_actual2ee_desired[2, 2])
    angle = math.acos(min((trace - 1.0) / 2.0, 1.0))
    orientation_error = min(angle, 2.0 * math.pi - angle)
    position_error = math.sqrt(
        ee_actual2ee_desired[0, 3] ** 2 + ee_actual2ee_desired[1, 3] ** 2
        + ee_actual2ee_desired[2, 3] ** 2)
    return (orientation_weight * orientation_error
            + position_weight * position_error)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="movement_primitives.kinematics.Chain"><code class="flex name class">
<span>class <span class="ident">Chain</span></span>
<span>(</span><span>tm, joint_names, base_frame, ee_frame, verbose=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Kinematic chain.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tm</code></strong> :&ensp;<code><a title="movement_primitives.kinematics.FastUrdfTransformManager" href="#movement_primitives.kinematics.FastUrdfTransformManager">FastUrdfTransformManager</a></code></dt>
<dd>Transformation manager</dd>
<dt><strong><code>joint_names</code></strong> :&ensp;<code>list</code></dt>
<dd>Names of joints that should be used</dd>
<dt><strong><code>base_frame</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the base link</dd>
<dt><strong><code>ee_frame</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the end-effector link</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int</code>, optional <code>(default: 0)</code></dt>
<dd>Verbosity level</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Chain:
    &#34;&#34;&#34;Kinematic chain.

    Parameters
    ----------
    tm : FastUrdfTransformManager
        Transformation manager

    joint_names : list
        Names of joints that should be used

    base_frame : str
        Name of the base link

    ee_frame : str
        Name of the end-effector link

    verbose : int, optional (default: 0)
        Verbosity level
    &#34;&#34;&#34;
    def __init__(self, tm, joint_names, base_frame, ee_frame, verbose=0):
        self.tm = tm
        self.joint_names = joint_names
        self.base_frame = base_frame
        self.ee_frame = ee_frame
        self.verbose = verbose

        self.joint_limits = np.array(
            [self.tm._joints[jn][4] for jn in self.joint_names])
        for i in range(len(self.joint_limits)):
            if np.isinf(self.joint_limits[i, 0]):
                self.joint_limits[i, 0] = -math.pi
            if np.isinf(self.joint_limits[i, 1]):
                self.joint_limits[i, 1] = math.pi

        self.n_joints = len(self.joint_names)
        assert len(self.joint_limits) == self.n_joints

        self.ee_index = self.tm.nodes.index(ee_frame)
        self.base_index = self.tm.nodes.index(base_frame)

    def forward(self, joint_angles):
        &#34;&#34;&#34;Forward kinematics.

        Parameters
        ----------
        joint_angles : array, shape (n_joints,)
            Joint angles

        Returns
        -------
        ee2base : array, shape (4, 4)
            Transformation from end-effector to base frame
        &#34;&#34;&#34;
        for i in range(self.n_joints):
            self.tm.set_joint(self.joint_names[i], joint_angles[i])
        return self.tm.get_ee2base(self.ee_index, self.base_index)

    def ee_pose_error(self, joint_angles, desired_pose, orientation_weight=1.0,
                      position_weight=1.0):
        &#34;&#34;&#34;Compute pose error.

        Parameters
        ----------
        joint_angles : array-like, shape (n_joints,)
            Actual joint angles for which we compute forward kinematics.

        desired_pose : array-like, shape (4, 4)
            Desired pose.

        orientation_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the orientation error.

        position_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the position error.

        Returns
        -------
        pose_error : float
            Weighted error between actual pose and desired pose.
        &#34;&#34;&#34;
        return pose_dist(desired_pose, self.forward(joint_angles),
                         orientation_weight, position_weight)

    def inverse(
            self, desired_pose, initial_joint_angles, return_error=False,
            bounds=None, solver=&#34;SLSQP&#34;, orientation_weight=1.0,
            position_weight=1.0):
        &#34;&#34;&#34;Inverse kinematics.

        Parameters
        ----------
        desired_pose : array, shape (4, 4)
            Desired transformation from end-effector to base frame

        initial_joint_angles : array, shape (n_joints,)
            Initial guess for joint angles

        return_error : bool, optional (default: False)
            Return error in addition to joint angles

        bounds : array, shape (n_joints, 2), optional (default: joint limits)
            Bounds for joint angle optimization

        solver : str, optional (default: &#39;SLSQP&#39;)
            Optimizer to solve inverse kinematics problem. Possible options:
            &#39;SLSQP&#39;, &#39;L-BFGS-B&#39;, and &#39;COBYLA&#39;.

        orientation_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the orientation error.

        position_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the position error.

        Returns
        -------
        joint_angles : array, shape (n_joints,)
            Solution

        error : float, optional
            Pose error
        &#34;&#34;&#34;
        if bounds is None:
            bounds = self.joint_limits
        res = minimize(
            self.ee_pose_error, initial_joint_angles,
            (desired_pose, orientation_weight, position_weight),
            method=solver, bounds=bounds)

        if self.verbose &gt;= 2:
            print(&#34;Error: %g&#34; % res[&#34;fun&#34;])
        if return_error:
            return res[&#34;x&#34;], res[&#34;fun&#34;]
        else:
            return res[&#34;x&#34;]

    def inverse_with_random_restarts(
            self, desired_pose, n_restarts=10, tolerance=1e-3,
            random_state=np.random, solver=&#34;SLSQP&#34;,
            orientation_weight=1.0, position_weight=1.0):
        &#34;&#34;&#34;Compute inverse kinematics with multiple random restarts.

        Parameters
        ----------
        desired_pose : array-like, shape (4, 4)
            Desired pose.

        n_restarts : int, optional (default: 10)
            Maximum number of allowed restarts.

        tolerance : float, optional (default: 1e-3)
            Required tolerance to abort.

        random_state : np.random.RandomState, optional (default: np.random)
            Random state.

        solver : str, optional (default: &#39;SLSQP&#39;)
            Optimizer to solve inverse kinematics problem. Possible options:
            &#39;SLSQP&#39;, &#39;L-BFGS-B&#39;, and &#39;COBYLA&#39;.

        orientation_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the orientation error.

        position_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the position error.

        Returns
        -------
        joint_angles : array, shape (n_joints,)
            Solution
        &#34;&#34;&#34;
        assert n_restarts &gt;= 1
        Q = []
        errors = []
        for _ in range(n_restarts):
            q, error = self.inverse(
                desired_pose, self._sample_joints_uniform(random_state),
                return_error=True, solver=solver,
                orientation_weight=orientation_weight,
                position_weight=position_weight)
            Q.append(q)
            errors.append(error)
            if error &lt;= tolerance:
                break
        if self.verbose:
            print(np.round(errors, 4))
        return Q[np.argmin(errors)]

    def local_inverse_with_random_restarts(
            self, desired_pose, joint_angles, interval, n_restarts=10,
            tolerance=1e-3, random_state=np.random, solver=&#34;SLSQP&#34;,
            orientation_weight=1.0, position_weight=1.0):
        &#34;&#34;&#34;Compute inverse kinematics with multiple random restarts.

        Parameters
        ----------
        desired_pose : array-like, shape (4, 4)
            Desired pose.

        joint_angles : array-like, shape (n_joints,)
            Initial guess for joint angles.

        interval : float
            We will search for a solution within the range
            [joint_angles - interval, joint_angles + interval].

        n_restarts : int, optional (default: 10)
            Maximum number of allowed restarts.

        tolerance : float, optional (default: 1e-3)
            Required tolerance to abort.

        random_state : np.random.RandomState, optional (default: np.random)
            Random state.

        solver : str, optional (default: &#39;SLSQP&#39;)
            Optimizer to solve inverse kinematics problem. Possible options:
            &#39;SLSQP&#39;, &#39;L-BFGS-B&#39;, and &#39;COBYLA&#39;.

        orientation_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the orientation error.

        position_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the position error.

        Returns
        -------
        joint_angles : array, shape (n_joints,)
            Solution
        &#34;&#34;&#34;
        assert n_restarts &gt;= 1
        Q = []
        errors = []
        bounds = np.empty((self.n_joints, 2))
        bounds[:, 0] = joint_angles - interval
        bounds[:, 1] = joint_angles + interval
        q = joint_angles  # start with previous state
        for _ in range(n_restarts):
            q, error = self.inverse(
                desired_pose, q, return_error=True, solver=solver,
                orientation_weight=orientation_weight,
                position_weight=position_weight)
            Q.append(q)
            errors.append(error)
            if error &lt;= tolerance:
                break
            q = self._sample_joints_uniform(random_state, bounds=bounds)
        return Q[np.argmin(errors)]

    def _sample_joints_uniform(self, random_state, bounds=None):
        if bounds is None:
            bounds = self.joint_limits
        return (random_state.rand(len(bounds)) * (bounds[:, 1] - bounds[:, 0])
                + bounds[:, 0])

    def forward_trajectory(self, Q):
        &#34;&#34;&#34;Compute forward kinematics for a trajectory.

        Parameters
        ----------
        Q : array-like, shape (n_steps, n_joints)
            Joint angles.

        Returns
        -------
        H : array, shape (n_steps, 4, 4)
            End-effector poses.
        &#34;&#34;&#34;
        H = np.empty((len(Q), 4, 4))
        for t in range(len(Q)):
            H[t] = self.forward(Q[t])
        return H

    def inverse_trajectory(
            self, H, initial_joint_angles=None, interval=0.1 * math.pi,
            random_restarts=True, random_state=np.random, solver=&#34;SLSQP&#34;,
            orientation_weight=1.0, position_weight=1.0):
        &#34;&#34;&#34;Compute inverse kinematics for a trajectory.

        Parameters
        ----------
        H : array-like, shape (n_steps, 4, 4)
            Desired end-effector poses.

        initial_joint_angles : array-like, shape (n_joints,), optional (default: None)
            Initial guess for joint angles.

        interval : float
            We will search for a solution within the range
            [joint_angles - interval, joint_angles + interval] in each step.

        random_restarts : bool, optional (default: True)
            Allow random restarts if no solution is found.

        random_state : np.random.RandomState, optional (default: np.random)
            Random state.

        solver : str, optional (default: &#39;SLSQP&#39;)
            Optimizer to solve inverse kinematics problem. Possible options:
            &#39;SLSQP&#39;, &#39;L-BFGS-B&#39;, and &#39;COBYLA&#39;.

        orientation_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the orientation error.

        position_weight : float, optional (default: 1.0)
            Should be between 0.0 and 1.0 and represent the weighting for
            minimizing the position error.

        Returns
        -------
        Q : array, shape (n_steps, n_joints)
            Solution
        &#34;&#34;&#34;
        Q = np.empty((len(H), len(self.joint_names)), dtype=float)

        if initial_joint_angles is None:
            Q[0] = self.inverse_with_random_restarts(
                H[0], random_state=random_state,
                orientation_weight=orientation_weight,
                position_weight=position_weight)
        else:
            Q[0] = self.inverse(
                H[0], initial_joint_angles, solver=solver,
                orientation_weight=orientation_weight,
                position_weight=position_weight)

        for t in range(1, len(H)):
            if self.verbose &gt;= 2:
                print(&#34;Step: %d&#34; % (t + 1))
            if random_restarts:
                Q[t] = self.local_inverse_with_random_restarts(
                    H[t], Q[t - 1], interval, random_state=random_state,
                    orientation_weight=orientation_weight,
                    position_weight=position_weight)
            else:
                bounds = np.empty((self.n_joints, 2), dtype=float)
                bounds[:, 0] = Q[t - 1] - interval
                bounds[:, 1] = Q[t - 1] + interval
                Q[t] = self.inverse(
                    H[t], Q[t - 1], False, bounds, solver=solver,
                    orientation_weight=orientation_weight,
                    position_weight=position_weight)
        return Q</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="movement_primitives.kinematics.Chain.ee_pose_error"><code class="name flex">
<span>def <span class="ident">ee_pose_error</span></span>(<span>self, joint_angles, desired_pose, orientation_weight=1.0, position_weight=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute pose error.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>joint_angles</code></strong> :&ensp;<code>array-like, shape (n_joints,)</code></dt>
<dd>Actual joint angles for which we compute forward kinematics.</dd>
<dt><strong><code>desired_pose</code></strong> :&ensp;<code>array-like, shape (4, 4)</code></dt>
<dd>Desired pose.</dd>
<dt><strong><code>orientation_weight</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1.0)</code></dt>
<dd>Should be between 0.0 and 1.0 and represent the weighting for
minimizing the orientation error.</dd>
<dt><strong><code>position_weight</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1.0)</code></dt>
<dd>Should be between 0.0 and 1.0 and represent the weighting for
minimizing the position error.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pose_error</code></strong> :&ensp;<code>float</code></dt>
<dd>Weighted error between actual pose and desired pose.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ee_pose_error(self, joint_angles, desired_pose, orientation_weight=1.0,
                  position_weight=1.0):
    &#34;&#34;&#34;Compute pose error.

    Parameters
    ----------
    joint_angles : array-like, shape (n_joints,)
        Actual joint angles for which we compute forward kinematics.

    desired_pose : array-like, shape (4, 4)
        Desired pose.

    orientation_weight : float, optional (default: 1.0)
        Should be between 0.0 and 1.0 and represent the weighting for
        minimizing the orientation error.

    position_weight : float, optional (default: 1.0)
        Should be between 0.0 and 1.0 and represent the weighting for
        minimizing the position error.

    Returns
    -------
    pose_error : float
        Weighted error between actual pose and desired pose.
    &#34;&#34;&#34;
    return pose_dist(desired_pose, self.forward(joint_angles),
                     orientation_weight, position_weight)</code></pre>
</details>
</dd>
<dt id="movement_primitives.kinematics.Chain.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, joint_angles)</span>
</code></dt>
<dd>
<div class="desc"><p>Forward kinematics.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>joint_angles</code></strong> :&ensp;<code>array, shape (n_joints,)</code></dt>
<dd>Joint angles</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ee2base</code></strong> :&ensp;<code>array, shape (4, 4)</code></dt>
<dd>Transformation from end-effector to base frame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forward(self, joint_angles):
    &#34;&#34;&#34;Forward kinematics.

    Parameters
    ----------
    joint_angles : array, shape (n_joints,)
        Joint angles

    Returns
    -------
    ee2base : array, shape (4, 4)
        Transformation from end-effector to base frame
    &#34;&#34;&#34;
    for i in range(self.n_joints):
        self.tm.set_joint(self.joint_names[i], joint_angles[i])
    return self.tm.get_ee2base(self.ee_index, self.base_index)</code></pre>
</details>
</dd>
<dt id="movement_primitives.kinematics.Chain.forward_trajectory"><code class="name flex">
<span>def <span class="ident">forward_trajectory</span></span>(<span>self, Q)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute forward kinematics for a trajectory.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Q</code></strong> :&ensp;<code>array-like, shape (n_steps, n_joints)</code></dt>
<dd>Joint angles.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>H</code></strong> :&ensp;<code>array, shape (n_steps, 4, 4)</code></dt>
<dd>End-effector poses.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forward_trajectory(self, Q):
    &#34;&#34;&#34;Compute forward kinematics for a trajectory.

    Parameters
    ----------
    Q : array-like, shape (n_steps, n_joints)
        Joint angles.

    Returns
    -------
    H : array, shape (n_steps, 4, 4)
        End-effector poses.
    &#34;&#34;&#34;
    H = np.empty((len(Q), 4, 4))
    for t in range(len(Q)):
        H[t] = self.forward(Q[t])
    return H</code></pre>
</details>
</dd>
<dt id="movement_primitives.kinematics.Chain.inverse"><code class="name flex">
<span>def <span class="ident">inverse</span></span>(<span>self, desired_pose, initial_joint_angles, return_error=False, bounds=None, solver='SLSQP', orientation_weight=1.0, position_weight=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Inverse kinematics.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>desired_pose</code></strong> :&ensp;<code>array, shape (4, 4)</code></dt>
<dd>Desired transformation from end-effector to base frame</dd>
<dt><strong><code>initial_joint_angles</code></strong> :&ensp;<code>array, shape (n_joints,)</code></dt>
<dd>Initial guess for joint angles</dd>
<dt><strong><code>return_error</code></strong> :&ensp;<code>bool</code>, optional <code>(default: False)</code></dt>
<dd>Return error in addition to joint angles</dd>
<dt><strong><code>bounds</code></strong> :&ensp;<code>array, shape (n_joints, 2)</code>, optional <code>(default: joint limits)</code></dt>
<dd>Bounds for joint angle optimization</dd>
<dt><strong><code>solver</code></strong> :&ensp;<code>str</code>, optional <code>(default: 'SLSQP')</code></dt>
<dd>Optimizer to solve inverse kinematics problem. Possible options:
'SLSQP', 'L-BFGS-B', and 'COBYLA'.</dd>
<dt><strong><code>orientation_weight</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1.0)</code></dt>
<dd>Should be between 0.0 and 1.0 and represent the weighting for
minimizing the orientation error.</dd>
<dt><strong><code>position_weight</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1.0)</code></dt>
<dd>Should be between 0.0 and 1.0 and represent the weighting for
minimizing the position error.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>joint_angles</code></strong> :&ensp;<code>array, shape (n_joints,)</code></dt>
<dd>Solution</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Pose error</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inverse(
        self, desired_pose, initial_joint_angles, return_error=False,
        bounds=None, solver=&#34;SLSQP&#34;, orientation_weight=1.0,
        position_weight=1.0):
    &#34;&#34;&#34;Inverse kinematics.

    Parameters
    ----------
    desired_pose : array, shape (4, 4)
        Desired transformation from end-effector to base frame

    initial_joint_angles : array, shape (n_joints,)
        Initial guess for joint angles

    return_error : bool, optional (default: False)
        Return error in addition to joint angles

    bounds : array, shape (n_joints, 2), optional (default: joint limits)
        Bounds for joint angle optimization

    solver : str, optional (default: &#39;SLSQP&#39;)
        Optimizer to solve inverse kinematics problem. Possible options:
        &#39;SLSQP&#39;, &#39;L-BFGS-B&#39;, and &#39;COBYLA&#39;.

    orientation_weight : float, optional (default: 1.0)
        Should be between 0.0 and 1.0 and represent the weighting for
        minimizing the orientation error.

    position_weight : float, optional (default: 1.0)
        Should be between 0.0 and 1.0 and represent the weighting for
        minimizing the position error.

    Returns
    -------
    joint_angles : array, shape (n_joints,)
        Solution

    error : float, optional
        Pose error
    &#34;&#34;&#34;
    if bounds is None:
        bounds = self.joint_limits
    res = minimize(
        self.ee_pose_error, initial_joint_angles,
        (desired_pose, orientation_weight, position_weight),
        method=solver, bounds=bounds)

    if self.verbose &gt;= 2:
        print(&#34;Error: %g&#34; % res[&#34;fun&#34;])
    if return_error:
        return res[&#34;x&#34;], res[&#34;fun&#34;]
    else:
        return res[&#34;x&#34;]</code></pre>
</details>
</dd>
<dt id="movement_primitives.kinematics.Chain.inverse_trajectory"><code class="name flex">
<span>def <span class="ident">inverse_trajectory</span></span>(<span>self, H, initial_joint_angles=None, interval=0.3141592653589793, random_restarts=True, random_state=&lt;module &#x27;numpy.random&#x27; from &#x27;/home/afabisch/Data/anaconda3/lib/python3.8/site-packages/numpy/random/__init__.py&#x27;&gt;, solver='SLSQP', orientation_weight=1.0, position_weight=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute inverse kinematics for a trajectory.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>H</code></strong> :&ensp;<code>array-like, shape (n_steps, 4, 4)</code></dt>
<dd>Desired end-effector poses.</dd>
<dt><strong><code>initial_joint_angles</code></strong> :&ensp;<code>array-like, shape (n_joints,)</code>, optional <code>(default: None)</code></dt>
<dd>Initial guess for joint angles.</dd>
<dt><strong><code>interval</code></strong> :&ensp;<code>float</code></dt>
<dd>We will search for a solution within the range
[joint_angles - interval, joint_angles + interval] in each step.</dd>
<dt><strong><code>random_restarts</code></strong> :&ensp;<code>bool</code>, optional <code>(default: True)</code></dt>
<dd>Allow random restarts if no solution is found.</dd>
<dt><strong><code>random_state</code></strong> :&ensp;<code>np.random.RandomState</code>, optional <code>(default: np.random)</code></dt>
<dd>Random state.</dd>
<dt><strong><code>solver</code></strong> :&ensp;<code>str</code>, optional <code>(default: 'SLSQP')</code></dt>
<dd>Optimizer to solve inverse kinematics problem. Possible options:
'SLSQP', 'L-BFGS-B', and 'COBYLA'.</dd>
<dt><strong><code>orientation_weight</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1.0)</code></dt>
<dd>Should be between 0.0 and 1.0 and represent the weighting for
minimizing the orientation error.</dd>
<dt><strong><code>position_weight</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1.0)</code></dt>
<dd>Should be between 0.0 and 1.0 and represent the weighting for
minimizing the position error.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Q</code></strong> :&ensp;<code>array, shape (n_steps, n_joints)</code></dt>
<dd>Solution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inverse_trajectory(
        self, H, initial_joint_angles=None, interval=0.1 * math.pi,
        random_restarts=True, random_state=np.random, solver=&#34;SLSQP&#34;,
        orientation_weight=1.0, position_weight=1.0):
    &#34;&#34;&#34;Compute inverse kinematics for a trajectory.

    Parameters
    ----------
    H : array-like, shape (n_steps, 4, 4)
        Desired end-effector poses.

    initial_joint_angles : array-like, shape (n_joints,), optional (default: None)
        Initial guess for joint angles.

    interval : float
        We will search for a solution within the range
        [joint_angles - interval, joint_angles + interval] in each step.

    random_restarts : bool, optional (default: True)
        Allow random restarts if no solution is found.

    random_state : np.random.RandomState, optional (default: np.random)
        Random state.

    solver : str, optional (default: &#39;SLSQP&#39;)
        Optimizer to solve inverse kinematics problem. Possible options:
        &#39;SLSQP&#39;, &#39;L-BFGS-B&#39;, and &#39;COBYLA&#39;.

    orientation_weight : float, optional (default: 1.0)
        Should be between 0.0 and 1.0 and represent the weighting for
        minimizing the orientation error.

    position_weight : float, optional (default: 1.0)
        Should be between 0.0 and 1.0 and represent the weighting for
        minimizing the position error.

    Returns
    -------
    Q : array, shape (n_steps, n_joints)
        Solution
    &#34;&#34;&#34;
    Q = np.empty((len(H), len(self.joint_names)), dtype=float)

    if initial_joint_angles is None:
        Q[0] = self.inverse_with_random_restarts(
            H[0], random_state=random_state,
            orientation_weight=orientation_weight,
            position_weight=position_weight)
    else:
        Q[0] = self.inverse(
            H[0], initial_joint_angles, solver=solver,
            orientation_weight=orientation_weight,
            position_weight=position_weight)

    for t in range(1, len(H)):
        if self.verbose &gt;= 2:
            print(&#34;Step: %d&#34; % (t + 1))
        if random_restarts:
            Q[t] = self.local_inverse_with_random_restarts(
                H[t], Q[t - 1], interval, random_state=random_state,
                orientation_weight=orientation_weight,
                position_weight=position_weight)
        else:
            bounds = np.empty((self.n_joints, 2), dtype=float)
            bounds[:, 0] = Q[t - 1] - interval
            bounds[:, 1] = Q[t - 1] + interval
            Q[t] = self.inverse(
                H[t], Q[t - 1], False, bounds, solver=solver,
                orientation_weight=orientation_weight,
                position_weight=position_weight)
    return Q</code></pre>
</details>
</dd>
<dt id="movement_primitives.kinematics.Chain.inverse_with_random_restarts"><code class="name flex">
<span>def <span class="ident">inverse_with_random_restarts</span></span>(<span>self, desired_pose, n_restarts=10, tolerance=0.001, random_state=&lt;module &#x27;numpy.random&#x27; from &#x27;/home/afabisch/Data/anaconda3/lib/python3.8/site-packages/numpy/random/__init__.py&#x27;&gt;, solver='SLSQP', orientation_weight=1.0, position_weight=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute inverse kinematics with multiple random restarts.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>desired_pose</code></strong> :&ensp;<code>array-like, shape (4, 4)</code></dt>
<dd>Desired pose.</dd>
<dt><strong><code>n_restarts</code></strong> :&ensp;<code>int</code>, optional <code>(default: 10)</code></dt>
<dd>Maximum number of allowed restarts.</dd>
<dt><strong><code>tolerance</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1e-3)</code></dt>
<dd>Required tolerance to abort.</dd>
<dt><strong><code>random_state</code></strong> :&ensp;<code>np.random.RandomState</code>, optional <code>(default: np.random)</code></dt>
<dd>Random state.</dd>
<dt><strong><code>solver</code></strong> :&ensp;<code>str</code>, optional <code>(default: 'SLSQP')</code></dt>
<dd>Optimizer to solve inverse kinematics problem. Possible options:
'SLSQP', 'L-BFGS-B', and 'COBYLA'.</dd>
<dt><strong><code>orientation_weight</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1.0)</code></dt>
<dd>Should be between 0.0 and 1.0 and represent the weighting for
minimizing the orientation error.</dd>
<dt><strong><code>position_weight</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1.0)</code></dt>
<dd>Should be between 0.0 and 1.0 and represent the weighting for
minimizing the position error.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>joint_angles</code></strong> :&ensp;<code>array, shape (n_joints,)</code></dt>
<dd>Solution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inverse_with_random_restarts(
        self, desired_pose, n_restarts=10, tolerance=1e-3,
        random_state=np.random, solver=&#34;SLSQP&#34;,
        orientation_weight=1.0, position_weight=1.0):
    &#34;&#34;&#34;Compute inverse kinematics with multiple random restarts.

    Parameters
    ----------
    desired_pose : array-like, shape (4, 4)
        Desired pose.

    n_restarts : int, optional (default: 10)
        Maximum number of allowed restarts.

    tolerance : float, optional (default: 1e-3)
        Required tolerance to abort.

    random_state : np.random.RandomState, optional (default: np.random)
        Random state.

    solver : str, optional (default: &#39;SLSQP&#39;)
        Optimizer to solve inverse kinematics problem. Possible options:
        &#39;SLSQP&#39;, &#39;L-BFGS-B&#39;, and &#39;COBYLA&#39;.

    orientation_weight : float, optional (default: 1.0)
        Should be between 0.0 and 1.0 and represent the weighting for
        minimizing the orientation error.

    position_weight : float, optional (default: 1.0)
        Should be between 0.0 and 1.0 and represent the weighting for
        minimizing the position error.

    Returns
    -------
    joint_angles : array, shape (n_joints,)
        Solution
    &#34;&#34;&#34;
    assert n_restarts &gt;= 1
    Q = []
    errors = []
    for _ in range(n_restarts):
        q, error = self.inverse(
            desired_pose, self._sample_joints_uniform(random_state),
            return_error=True, solver=solver,
            orientation_weight=orientation_weight,
            position_weight=position_weight)
        Q.append(q)
        errors.append(error)
        if error &lt;= tolerance:
            break
    if self.verbose:
        print(np.round(errors, 4))
    return Q[np.argmin(errors)]</code></pre>
</details>
</dd>
<dt id="movement_primitives.kinematics.Chain.local_inverse_with_random_restarts"><code class="name flex">
<span>def <span class="ident">local_inverse_with_random_restarts</span></span>(<span>self, desired_pose, joint_angles, interval, n_restarts=10, tolerance=0.001, random_state=&lt;module &#x27;numpy.random&#x27; from &#x27;/home/afabisch/Data/anaconda3/lib/python3.8/site-packages/numpy/random/__init__.py&#x27;&gt;, solver='SLSQP', orientation_weight=1.0, position_weight=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute inverse kinematics with multiple random restarts.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>desired_pose</code></strong> :&ensp;<code>array-like, shape (4, 4)</code></dt>
<dd>Desired pose.</dd>
<dt><strong><code>joint_angles</code></strong> :&ensp;<code>array-like, shape (n_joints,)</code></dt>
<dd>Initial guess for joint angles.</dd>
<dt><strong><code>interval</code></strong> :&ensp;<code>float</code></dt>
<dd>We will search for a solution within the range
[joint_angles - interval, joint_angles + interval].</dd>
<dt><strong><code>n_restarts</code></strong> :&ensp;<code>int</code>, optional <code>(default: 10)</code></dt>
<dd>Maximum number of allowed restarts.</dd>
<dt><strong><code>tolerance</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1e-3)</code></dt>
<dd>Required tolerance to abort.</dd>
<dt><strong><code>random_state</code></strong> :&ensp;<code>np.random.RandomState</code>, optional <code>(default: np.random)</code></dt>
<dd>Random state.</dd>
<dt><strong><code>solver</code></strong> :&ensp;<code>str</code>, optional <code>(default: 'SLSQP')</code></dt>
<dd>Optimizer to solve inverse kinematics problem. Possible options:
'SLSQP', 'L-BFGS-B', and 'COBYLA'.</dd>
<dt><strong><code>orientation_weight</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1.0)</code></dt>
<dd>Should be between 0.0 and 1.0 and represent the weighting for
minimizing the orientation error.</dd>
<dt><strong><code>position_weight</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1.0)</code></dt>
<dd>Should be between 0.0 and 1.0 and represent the weighting for
minimizing the position error.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>joint_angles</code></strong> :&ensp;<code>array, shape (n_joints,)</code></dt>
<dd>Solution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def local_inverse_with_random_restarts(
        self, desired_pose, joint_angles, interval, n_restarts=10,
        tolerance=1e-3, random_state=np.random, solver=&#34;SLSQP&#34;,
        orientation_weight=1.0, position_weight=1.0):
    &#34;&#34;&#34;Compute inverse kinematics with multiple random restarts.

    Parameters
    ----------
    desired_pose : array-like, shape (4, 4)
        Desired pose.

    joint_angles : array-like, shape (n_joints,)
        Initial guess for joint angles.

    interval : float
        We will search for a solution within the range
        [joint_angles - interval, joint_angles + interval].

    n_restarts : int, optional (default: 10)
        Maximum number of allowed restarts.

    tolerance : float, optional (default: 1e-3)
        Required tolerance to abort.

    random_state : np.random.RandomState, optional (default: np.random)
        Random state.

    solver : str, optional (default: &#39;SLSQP&#39;)
        Optimizer to solve inverse kinematics problem. Possible options:
        &#39;SLSQP&#39;, &#39;L-BFGS-B&#39;, and &#39;COBYLA&#39;.

    orientation_weight : float, optional (default: 1.0)
        Should be between 0.0 and 1.0 and represent the weighting for
        minimizing the orientation error.

    position_weight : float, optional (default: 1.0)
        Should be between 0.0 and 1.0 and represent the weighting for
        minimizing the position error.

    Returns
    -------
    joint_angles : array, shape (n_joints,)
        Solution
    &#34;&#34;&#34;
    assert n_restarts &gt;= 1
    Q = []
    errors = []
    bounds = np.empty((self.n_joints, 2))
    bounds[:, 0] = joint_angles - interval
    bounds[:, 1] = joint_angles + interval
    q = joint_angles  # start with previous state
    for _ in range(n_restarts):
        q, error = self.inverse(
            desired_pose, q, return_error=True, solver=solver,
            orientation_weight=orientation_weight,
            position_weight=position_weight)
        Q.append(q)
        errors.append(error)
        if error &lt;= tolerance:
            break
        q = self._sample_joints_uniform(random_state, bounds=bounds)
    return Q[np.argmin(errors)]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="movement_primitives.kinematics.FastUrdfTransformManager"><code class="flex name class">
<span>class <span class="ident">FastUrdfTransformManager</span></span>
</code></dt>
<dd>
<div class="desc"><p>Transformation manager that can load URDF files.</p>
<p>URDF is the <code>Unified Robot Description Format &lt;http://wiki.ros.org/urdf&gt;</code>_.
URDF allows to define joints between links that can be rotated about one
axis. This transformation manager allows to set the joint angles after
joints have been added or loaded from an URDF.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Note that this module requires the Python package beautifulsoup4.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Joint angles must be given in radians.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>strict_check</code></strong> :&ensp;<code>bool</code>, optional <code>(default: True)</code></dt>
<dd>Raise a ValueError if the transformation matrix is not numerically
close enough to a real transformation matrix. Otherwise we print a
warning.</dd>
<dt><strong><code>check</code></strong> :&ensp;<code>bool</code>, optional <code>(default: True)</code></dt>
<dd>Check if transformation matrices are valid and requested nodes exist,
which might significantly slow down some operations.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FastUrdfTransformManager(UrdfTransformManager):
    def __init__(self):
        super(FastUrdfTransformManager, self).__init__(check=False)

    def set_joint(self, joint_name, value):
        &#34;&#34;&#34;Set joint position.

        Note that joint values are clipped to their limits.

        Parameters
        ----------
        joint_name : string
            Name of the joint

        value : float
            Joint angle in radians in case of revolute joints or position
            in case of prismatic joint.
        &#34;&#34;&#34;
        from_frame, to_frame, child2parent, axis, limits, joint_type = \
            self._joints[joint_name]
        value = min(max(value, limits[0]), limits[1])
        if joint_type == &#34;revolute&#34;:
            joint2A = _fast_matrix_from_axis_angle(axis, value)
        else:
            joint2A = np.eye(4)
            joint2A[:3, 3] = value * axis
        self.transforms[(from_frame, to_frame)] = child2parent.dot(joint2A)

    def get_ee2base(self, ee_index, base_index):
        &#34;&#34;&#34;Request a transform.

        Parameters
        ----------
        ee_index : int
            Index of the end-effector node

        base_index : int
            Index of the base node

        Returns
        -------
        ee2base : array-like, shape (4, 4)
            Homogeneous matrix that represents the transform from ee to base
        &#34;&#34;&#34;
        return self._path_transform(self._shortest_path(ee_index, base_index))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pytransform3d.urdf.UrdfTransformManager</li>
<li>pytransform3d.transform_manager.TransformManager</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="movement_primitives.kinematics.FastUrdfTransformManager.get_ee2base"><code class="name flex">
<span>def <span class="ident">get_ee2base</span></span>(<span>self, ee_index, base_index)</span>
</code></dt>
<dd>
<div class="desc"><p>Request a transform.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ee_index</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the end-effector node</dd>
<dt><strong><code>base_index</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the base node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ee2base</code></strong> :&ensp;<code>array-like, shape (4, 4)</code></dt>
<dd>Homogeneous matrix that represents the transform from ee to base</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ee2base(self, ee_index, base_index):
    &#34;&#34;&#34;Request a transform.

    Parameters
    ----------
    ee_index : int
        Index of the end-effector node

    base_index : int
        Index of the base node

    Returns
    -------
    ee2base : array-like, shape (4, 4)
        Homogeneous matrix that represents the transform from ee to base
    &#34;&#34;&#34;
    return self._path_transform(self._shortest_path(ee_index, base_index))</code></pre>
</details>
</dd>
<dt id="movement_primitives.kinematics.FastUrdfTransformManager.set_joint"><code class="name flex">
<span>def <span class="ident">set_joint</span></span>(<span>self, joint_name, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set joint position.</p>
<p>Note that joint values are clipped to their limits.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>joint_name</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the joint</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Joint angle in radians in case of revolute joints or position
in case of prismatic joint.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_joint(self, joint_name, value):
    &#34;&#34;&#34;Set joint position.

    Note that joint values are clipped to their limits.

    Parameters
    ----------
    joint_name : string
        Name of the joint

    value : float
        Joint angle in radians in case of revolute joints or position
        in case of prismatic joint.
    &#34;&#34;&#34;
    from_frame, to_frame, child2parent, axis, limits, joint_type = \
        self._joints[joint_name]
    value = min(max(value, limits[0]), limits[1])
    if joint_type == &#34;revolute&#34;:
        joint2A = _fast_matrix_from_axis_angle(axis, value)
    else:
        joint2A = np.eye(4)
        joint2A[:3, 3] = value * axis
    self.transforms[(from_frame, to_frame)] = child2parent.dot(joint2A)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="movement_primitives.kinematics.Kinematics"><code class="flex name class">
<span>class <span class="ident">Kinematics</span></span>
<span>(</span><span>urdf, mesh_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Robot kinematics.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>urdf</code></strong> :&ensp;<code>str</code></dt>
<dd>URDF description of a robot</dd>
<dt><strong><code>mesh_path</code></strong> :&ensp;<code>str</code>, optional <code>(default: None)</code></dt>
<dd>Path in which we search for meshes that are defined in the URDF.
Meshes will be ignored if it is set to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Kinematics:
    &#34;&#34;&#34;Robot kinematics.

    Parameters
    ----------
    urdf : str
        URDF description of a robot

    mesh_path : str, optional (default: None)
        Path in which we search for meshes that are defined in the URDF.
        Meshes will be ignored if it is set to None.
    &#34;&#34;&#34;
    def __init__(self, urdf, mesh_path=None):
        self.tm = FastUrdfTransformManager()
        self.tm.load_urdf(urdf, mesh_path=mesh_path)

    def create_chain(self, joint_names, base_frame, ee_frame, verbose=0):
        &#34;&#34;&#34;Create kinematic chain.

        Parameters
        ----------
        joint_names : list
            Names of joints that should be used

        base_frame : str
            Name of the base link

        ee_frame : str
            Name of the end-effector link

        verbose : int, optional (default: 0)
            Verbosity level

        Returns
        -------
        chain : Chain
            Kinematic chain
        &#34;&#34;&#34;
        return Chain(self.tm, joint_names, base_frame, ee_frame, verbose)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="movement_primitives.kinematics.Kinematics.create_chain"><code class="name flex">
<span>def <span class="ident">create_chain</span></span>(<span>self, joint_names, base_frame, ee_frame, verbose=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Create kinematic chain.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>joint_names</code></strong> :&ensp;<code>list</code></dt>
<dd>Names of joints that should be used</dd>
<dt><strong><code>base_frame</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the base link</dd>
<dt><strong><code>ee_frame</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the end-effector link</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int</code>, optional <code>(default: 0)</code></dt>
<dd>Verbosity level</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>chain</code></strong> :&ensp;<code><a title="movement_primitives.kinematics.Chain" href="#movement_primitives.kinematics.Chain">Chain</a></code></dt>
<dd>Kinematic chain</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_chain(self, joint_names, base_frame, ee_frame, verbose=0):
    &#34;&#34;&#34;Create kinematic chain.

    Parameters
    ----------
    joint_names : list
        Names of joints that should be used

    base_frame : str
        Name of the base link

    ee_frame : str
        Name of the end-effector link

    verbose : int, optional (default: 0)
        Verbosity level

    Returns
    -------
    chain : Chain
        Kinematic chain
    &#34;&#34;&#34;
    return Chain(self.tm, joint_names, base_frame, ee_frame, verbose)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="movement_primitives" href="index.html">movement_primitives</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="movement_primitives.kinematics.pose_dist" href="#movement_primitives.kinematics.pose_dist">pose_dist</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="movement_primitives.kinematics.Chain" href="#movement_primitives.kinematics.Chain">Chain</a></code></h4>
<ul class="">
<li><code><a title="movement_primitives.kinematics.Chain.ee_pose_error" href="#movement_primitives.kinematics.Chain.ee_pose_error">ee_pose_error</a></code></li>
<li><code><a title="movement_primitives.kinematics.Chain.forward" href="#movement_primitives.kinematics.Chain.forward">forward</a></code></li>
<li><code><a title="movement_primitives.kinematics.Chain.forward_trajectory" href="#movement_primitives.kinematics.Chain.forward_trajectory">forward_trajectory</a></code></li>
<li><code><a title="movement_primitives.kinematics.Chain.inverse" href="#movement_primitives.kinematics.Chain.inverse">inverse</a></code></li>
<li><code><a title="movement_primitives.kinematics.Chain.inverse_trajectory" href="#movement_primitives.kinematics.Chain.inverse_trajectory">inverse_trajectory</a></code></li>
<li><code><a title="movement_primitives.kinematics.Chain.inverse_with_random_restarts" href="#movement_primitives.kinematics.Chain.inverse_with_random_restarts">inverse_with_random_restarts</a></code></li>
<li><code><a title="movement_primitives.kinematics.Chain.local_inverse_with_random_restarts" href="#movement_primitives.kinematics.Chain.local_inverse_with_random_restarts">local_inverse_with_random_restarts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="movement_primitives.kinematics.FastUrdfTransformManager" href="#movement_primitives.kinematics.FastUrdfTransformManager">FastUrdfTransformManager</a></code></h4>
<ul class="">
<li><code><a title="movement_primitives.kinematics.FastUrdfTransformManager.get_ee2base" href="#movement_primitives.kinematics.FastUrdfTransformManager.get_ee2base">get_ee2base</a></code></li>
<li><code><a title="movement_primitives.kinematics.FastUrdfTransformManager.set_joint" href="#movement_primitives.kinematics.FastUrdfTransformManager.set_joint">set_joint</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="movement_primitives.kinematics.Kinematics" href="#movement_primitives.kinematics.Kinematics">Kinematics</a></code></h4>
<ul class="">
<li><code><a title="movement_primitives.kinematics.Kinematics.create_chain" href="#movement_primitives.kinematics.Kinematics.create_chain">create_chain</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>